# Code Review: Semantic Indexing Feature

**Date:** 2026-02-21  
**Review Focus:** Security, Logic  
**Files Changed:** 7 files

---

## Summary

These changes add a semantic code indexing feature using Qdrant (vector database) and Ollama (embedding model). The feature allows the LLM to search the codebase for relevant context during conversations.

---

## Security Issues

### 1. Sensitive Files Not Excluded from Indexing (CRITICAL)

**Files Affected:**

- `packages/opencode/src/indexer/index.ts` (lines 162-166, 130-160)

**Problem:**  
The `FileIgnore` filter does not exclude sensitive files like `.env`, `credentials.json`, `.pem`, `.key`, or other secret files. The indexer will read and store the contents of these files in the vector database (Qdrant), potentially exposing secrets.

```typescript
// Line 164-166: Only filters by FileIgnore, which misses sensitive files
const files = (await Glob.scan("**/*", { cwd: Instance.directory, ... })).filter(
  (f) => !FileIgnore.match(path.relative(Instance.directory, f)),
)
```

**Current FileIgnore patterns (`src/file/ignore.ts`):**

- Folders: `node_modules`, `.git`, `.vscode`, etc.
- Files: `*.swp`, `*.log`, `.DS_Store`, `coverage/**`, etc.

**Missing patterns:**

- `**/.env*`
- `**/credentials.json`
- `**/*.pem`, `**/*.key`
- `**/secrets/**`
- `**/.aws/**`
- `**/.ssh/**`

**Recommendation:**  
Add sensitive file patterns to `FileIgnore.FILES` in `src/file/ignore.ts`:

```typescript
const FILES = [
  // ... existing patterns
  "**/.env*",
  "**/credentials.json",
  "**/*.pem",
  "**/*.key",
  "**/secrets/**",
  "**/.aws/**",
  "**/.ssh/**",
]
```

---

### 2. No Input Validation/Length Limits on Search Query (MAJOR)

**File:** `packages/opencode/src/indexer/index.ts` (lines 218-234)

**Problem:**  
The `search()` function accepts any string without validation or length limits. A malicious user could send extremely long queries to cause denial of service against the embedding service or Qdrant.

```typescript
export async function search(query: string, topK = 5): Promise<string[]> {
  const vector = await embed(query) // No length validation
  // ... passes to Qdrant
}
```

**Recommendation:**  
Add input validation:

```typescript
const MAX_QUERY_LENGTH = 1000

export async function search(query: string, topK = 5): Promise<string[]> {
  if (!query || query.length > MAX_QUERY_LENGTH) {
    throw new Error("Invalid query length")
  }
  // ...
}
```

---

### 3. Sensitive Code Context Sent to LLM (MAJOR)

**File:** `packages/opencode/src/session/llm.ts` (lines 170-188)

**Problem:**  
Indexed code content is injected into the LLM prompt without any filtering for sensitive information. If the indexer indexed sensitive files (see issue #1), those secrets would be sent to the LLM and potentially logged or leaked through AI provider APIs.

```typescript
// Lines 178-185: Raw indexed content injected into LLM context
const chunks = await Indexer.search(userText, 5).catch(() => [] as string[])
if (chunks.length > 0) {
  system.push(
    "<codebase_context>\nRelevant code from this project:\n\n" +
      chunks.join("\n\n") + // Could contain secrets!
      "\n</codebase_context>",
  )
}
```

**Recommendation:**  
Either:

1. Ensure sensitive files are excluded from indexing (fix issue #1)
2. Add content filtering before injecting into LLM context to redact potential secrets (e.g., look for patterns like `password=`, `api_key=`, `Bearer `, etc.)

---

---

## Critical Logic Issues

### 4. Blocking I/O in async context

**File:** `packages/opencode/src/indexer/index.ts:150-161`

```typescript
const stat = fs.statSync(filePath)
if (!stat.isFile()) return
...
const content = fs.readFileSync(filePath, "utf-8")
```

**Problem:** Using synchronous file operations (`statSync`, `readFileSync`) blocks the event loop. Since this runs during initial indexing of potentially thousands of files, it can cause UI freezes or timeouts.

**Fix:** Use async versions:

```typescript
const stat = await Bun.file(filePath).stat()
const content = await Bun.file(filePath).text()
```

---

### 5. No timeout on external HTTP requests

**File:** `packages/opencode/src/indexer/index.ts:69-78`

```typescript
async function embed(text: string): Promise<number[]> {
  const url = embeddingUrl()
  const response = await fetch(`${url}/api/embeddings`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ model: embeddingModel(), prompt: text }),
  })
```

**Problem:** No timeout means if Ollama is slow/unavailable, the entire indexing or LLM call hangs indefinitely.

**Fix:** Add a timeout:

```typescript
const response = await fetch(`${url}/api/embeddings`, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  signal: AbortSignal.timeout(30000),
  body: JSON.stringify({ model: embeddingModel(), prompt: text }),
})
```

---

### 6. LLM request path includes blocking network call

**File:** `packages/opencode/src/session/llm.ts:170-186`

```typescript
if (Indexer.status().type === "complete") {
  const lastUserContent = input.messages.findLast((m) => m.role === "user")?.content
  ...
  if (userText.trim()) {
    const chunks = await Indexer.search(userText, 5).catch(() => [] as string[])
```

**Problem:** This is called **synchronously in the LLM request pipeline**. If Indexer.search() is slow, the entire response is delayed. Also, `.catch(() => [] as string[])` silently swallows errorsâ€”you'll never know if Qdrant is down.

**Fix:** At minimum, log errors instead of silent swallowing:

```typescript
const chunks = await Indexer.search(userText, 5).catch((e) => {
  Log.Default.warn("indexer search failed", { error: String(e) })
  return [] as string[]
})
```

---

## Major Logic Issues

### 7. Type bypass with `any`

**File:** `packages/opencode/src/cli/cmd/tui/context/sync.tsx:351`

```typescript
void (sdk.client as any).client.get({ url: "/indexer" })
```

**Problem:** Using `any` defeats TypeScript's type safety. The SDK should have proper typing for custom endpoints.

**Fix:** Add proper typing to the SDK client or use a typed wrapper.

---

### 8. Silent error swallowing

**File:** `packages/opencode/src/indexer/index.ts:183-185`

```typescript
} catch {
  // ignore errors
}
```

**Problem:** Silent swallowing makes debugging impossible. At minimum, log the error.

---

### 9. No connection availability check

**File:** `packages/opencode/src/indexer/index.ts:236-244`

```typescript
export function init() {
  if (!VuHitraSettings.indexingEnabled()) return
  const s = state()
  s.status = { type: "indexing", progress: 0 }
  Promise.resolve().then(async () => {
    await runInitialIndex()
    watchForChanges()
  })
}
```

**Problem:** If Qdrant/Ollama aren't running, indexing fails silently and the status stays at "indexing" forever (or crashes). Should verify services are available before setting status to "indexing".

---

## Minor Issues

### 10. Event spam during indexing

**File:** `packages/opencode/src/indexer/index.ts:199`

```typescript
done++
state().status = { type: "indexing", progress: Math.round((done / files.length) * 100) }
Bus.publish(Event.Updated, {})
```

**Problem:** Publishing an event after **every single file** creates excessive bus events. For large projects (10k+ files), this is thousands of events. Consider throttling or updating less frequently.

---

### 11. Unbounded file size limit

**File:** `packages/opencode/src/indexer/index.ts:154`

```typescript
if (stat.size > 1024 * 1024) return
```

**Problem:** 1MB limit is hardcoded but should likely be configurable or at least documented.

---

### 12. Missing `Content-Length` header consideration

**File:** `packages/opencode/src/indexer/index.ts:70-75`

The embedding API might reject requests without proper headers. Currently only sets `Content-Type`. May need `Accept` header for better compatibility.

---

## Style Notes

**File:** `packages/opencode/src/session/llm.ts:173-176`

```typescript
const userText = Array.isArray(lastUserContent)
  ? (lastUserContent as any[])
      .filter((p: any) => p.type === "text")
```

Multiple `any` usages here. Consider typing the message content properly.

---

## Issue Count by Severity

| Severity     | Count |
| ------------ | ----- |
| **Critical** | 4     |
| **Major**    | 5     |
| **Minor**    | 3     |

---

## Recommendation

The critical issues (#1, #4, #5, #6) should be addressed before merging, as they can cause security breaches or make the application hang/unresponsive. The major issues (#2, #3, #7, #8, #9) should also be addressed for security hardening, maintainability, and debuggability.
