# Pass Over Feature Architecture

## Overview

The **pass over feature** enables agents to delegate work to specialized subagents (e.g., Alice → Audit → Alice return cycle) with complete context preservation, output capture, and controlled return mechanisms. This document defines the complete architecture, data structures, and control flow.

## 1. Conceptual Model

### 1.1 Pass Over Cycle

```
┌─────────────────────────────────────────────────────────────────┐
│                      Originating Agent                           │
│                        (e.g., Alice)                             │
│  • Identifies work needing specialized handling                  │
│  • Constructs PassOverRequest with work context                  │
│  • Awaits WorkOutput with results + metadata                     │
│  • Continues session with returned context                       │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       │ PassOverRequest
                       │ • originating_agent_id: "alice"
                       │ • subagent_id: "audit"
                       │ • work_context: {...}
                       │ • reason: "review_changes"
                       │ • return_required: true
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Subagent                                      │
│                   (e.g., Audit)                                  │
│  • Receives PassOverContext with full work scope                 │
│  • Executes specialized task(s)                                  │
│  • Collects tool results, file modifications, decisions          │
│  • Generates WorkOutput with all artifacts                       │
│  • Returns with return_to marker + metadata                      │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       │ WorkOutput
                       │ • work_id: uuid
                       │ • subagent_id: "audit"
                       │ • status: "completed" | "failed" | "aborted"
                       │ • artifacts: [files, messages, decisions]
                       │ • metadata: {...}
                       │ • return_to: "alice"
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Originating Agent                           │
│                        (e.g., Alice)                             │
│  • Receives WorkOutput from Audit                                │
│  • Processes results (approves, rejects, or adjusts)             │
│  • Updates session state with subagent's work                    │
│  • Continues main workflow                                       │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 Key Principles

- **Complete Context**: All necessary information flows to the subagent; no loss of session state
- **Immutable Origination**: The originating agent is permanently recorded and cannot be lost
- **Atomic Passes**: A single pass over is atomic; either fully accepted or rejected
- **Traceable**: Every pass over leave audit trail with timestamp, reason, and outcome
- **Configurable**: User can set per-pair preferences and override behaviors inline
- **Loop Prevention**: Built-in guards against infinite delegation loops
- **Asynchronous Safe**: Pass overs are thread-safe and handle concurrent operations

---

## 2. Data Structures

### 2.1 PassOverRequest

Sent by originating agent to initiate delegation.

```typescript
interface PassOverRequest {
  // Identity
  id: string // UUID, generated by originator
  originating_agent_id: string // e.g., "alice", "scout", "audit"
  subagent_id: string // target agent, e.g., "audit", "inspector"

  // Execution Context
  work_context: WorkContext // see 2.2

  // Metadata
  reason: string // e.g., "review_changes", "validate_approach", "fix_syntax_errors"
  priority?: "low" | "medium" | "high" // affects subagent scheduling
  timeout_ms?: number // max time for subagent to execute (default: 30000)

  // Control
  return_required: boolean // if true, originator must handle return
  auto_apply_on_success?: boolean // if true, apply results without review (requires policy)

  // Hints for subagent
  constraints?: string[] // e.g., ["no_external_calls", "read_only"]
  expected_output_type?: "decision" | "artifacts" | "report" | "mixed"
}
```

### 2.2 WorkContext

Complete snapshot of work to be passed.

```typescript
interface WorkContext {
  // Session Info
  session_id: string
  directory: string

  // File State
  files: {
    path: string
    content?: string // null if read not needed; sparse for large files
    metadata?: {
      size_bytes: number
      last_modified: number // unix timestamp
      is_binary: boolean
    }
  }[]

  // Conversation History (relevant portion)
  messages: {
    id: string
    role: "user" | "assistant"
    agent_name?: string
    parts: MessagePart[]
    timestamp: number
  }[]

  // Tool Results (from current attempt)
  tool_results?: {
    tool_name: string
    call_id: string
    status: "pending" | "in_progress" | "completed" | "error"
    input: Record<string, any>
    output?: string
    error?: string
    timestamp: number
  }[]

  // Current Session State
  todos?: Todo[]
  errors?: {
    type: string
    message: string
    context?: string
  }[]

  // Work Description
  objective: string // what needs to be reviewed/fixed/validated
  background?: string // why this work is being passed over
}
```

### 2.3 WorkOutput

Returned by subagent to originating agent.

```typescript
interface WorkOutput {
  // Identity & Traceability
  work_id: string // matches PassOverRequest.id
  subagent_id: string // which agent performed the work
  originating_agent_id: string // where it came from (copied from request)

  // Result Status
  status: "completed" | "failed" | "aborted" | "partial"
  completion_reason?: string

  // Artifacts
  artifacts: WorkArtifact[] // see 2.4

  // Summary
  summary: {
    // Decision (if applicable)
    decision?: "approved" | "rejected" | "needs_modification" | "blocked"
    decision_reason?: string

    // Findings
    findings: string[] // e.g., ["Line 42 has logic error", "Missing null check"]

    // Recommendations
    recommendations?: string[] // what originator should do

    // Statistics
    files_modified: number
    files_reviewed: number
    issues_found: number
    time_elapsed_ms: number
  }

  // Return Control
  return_to: string // originating agent, must match request's originating_agent_id
  auto_apply_allowed: boolean // true if subagent says results can be auto-applied

  // Metadata
  metadata: PassOverMetadata // see 2.5
}
```

### 2.4 WorkArtifact

Individual result from subagent work.

```typescript
type WorkArtifact = FileModificationArtifact | DecisionArtifact | MessageArtifact | FindingArtifact | ToolResultArtifact

interface FileModificationArtifact {
  type: "file_modification"
  path: string
  old_content: string
  new_content: string
  reason: string // why this change
  confidence: "high" | "medium" | "low"
}

interface DecisionArtifact {
  type: "decision"
  id: string
  question: string // what decision was made
  answer: "yes" | "no" | "unknown"
  reasoning: string
  alternatives_considered?: string[]
}

interface MessageArtifact {
  type: "message"
  role: "assistant" | "internal"
  content: string
  visibility: "originator_only" | "user_visible"
}

interface FindingArtifact {
  type: "finding"
  severity: "error" | "warning" | "info"
  category: string // "logic_error", "style", "performance", etc.
  message: string
  location?: {
    path: string
    line?: number
    column?: number
  }
  suggested_fix?: string
}

interface ToolResultArtifact {
  type: "tool_result"
  tool_name: string
  call_id: string
  input: Record<string, any>
  output: string
  status: "success" | "error"
}
```

### 2.5 PassOverMetadata

Metadata tracking for pass over lifecycle.

```typescript
interface PassOverMetadata {
  // Timing
  created_at: number // unix timestamp when requested
  started_at?: number // when subagent started execution
  completed_at?: number // when subagent finished
  returned_at?: number // when results reached originator

  // Tracing
  pass_over_id: string // unique identifier for this pass over
  trace_id?: string // parent trace ID for correlation across systems
  chain_depth: number // how many passes in this chain (prevents loops)

  // Origination Chain
  origination_chain: {
    agent_id: string
    timestamp: number
    action: "initiated" | "delegated" | "returned"
  }[]

  // Policy Applied
  policy_name?: string // which user preference was used
  policy_override?: boolean // true if inline override was used

  // Performance
  wall_time_ms: number // total elapsed time
  subagent_compute_ms: number // actual compute time (excl. waits)

  // Outcome
  applied: boolean // whether originator applied the results
  applied_at?: number
  applied_by?: string // who approved application
}
```

---

## 3. Message Structure & Capture

### 3.1 Capturing Work Output from Conversation

Work output is extracted from agent message history:

```typescript
interface MessagePart {
  id: string
  type: "text" | "tool" | "file" | "reasoning"

  // For text parts
  text?: string
  synthetic?: boolean // true if generated, not from user
  ignored?: boolean // true if meant only for agent

  // For tool parts
  tool_name?: string
  call_id?: string
  tool_status?: "pending" | "running" | "completed" | "error"
  tool_input?: Record<string, any>
  tool_output?: string
  tool_error?: string

  // For file parts
  file_url?: string
  file_path?: string
  file_mime?: string

  // Metadata
  timestamp?: number
  metadata?: Record<string, any>
}

// Extraction logic
function extractWorkOutput(messages: Message[], agentID: string): WorkArtifact[] {
  const artifacts: WorkArtifact[] = []

  // Scan all assistant messages from the agent
  for (const msg of messages) {
    if (msg.role !== "assistant" || msg.agent_id !== agentID) continue

    for (const part of msg.parts) {
      // Tool results → ToolResultArtifacts
      if (part.type === "tool" && part.tool_status === "completed") {
        artifacts.push({
          type: "tool_result",
          tool_name: part.tool_name!,
          call_id: part.call_id!,
          input: part.tool_input || {},
          output: part.tool_output || "",
          status: "success",
        })
      }

      // File modifications → FileModificationArtifacts
      if (part.type === "file" && part.file_path) {
        // Extract from tool history that matches this file
        const toolResult = messages.find((m) => m.parts.some((p) => p.type === "tool" && p.tool_name === "edit"))
        if (toolResult) {
          artifacts.push({
            type: "file_modification",
            path: part.file_path,
            old_content: extractOldContent(toolResult),
            new_content: extractNewContent(toolResult),
            reason: part.metadata?.reason || "",
            confidence: "high",
          })
        }
      }

      // Decisions from reasoning/text
      if (part.type === "reasoning" && part.text?.includes("DECISION:")) {
        artifacts.push({
          type: "decision",
          id: part.id,
          question: extractQuestion(part.text),
          answer: extractAnswer(part.text),
          reasoning: part.text,
        })
      }
    }
  }

  return artifacts
}
```

### 3.2 Message Flow Through Pass Over

```
Original Session Messages:
├── User: "Review this code"
├── Alice: "I'll review. Let me call audit..."
│   ├── Tool: bash (grep for errors) → pending
│   └── Tool: bash (grep for errors) → completed
├── PassOverMarker: {
│    originating_agent: "alice",
│    subagent: "audit",
│    reason: "detailed_review"
│   }
│
├── [Audit session in isolated context]
│   ├── Audit: "Reviewing code..."
│   ├── Tool: read (file) → completed
│   ├── Tool: bash (analysis) → completed
│   └── Audit: "Found 3 issues"
│
└── PassOverReturnMarker: {
     work_output: {...},
     return_to: "alice"
    }

Alice Continues:
├── Alice: "Audit found 3 issues. Let me apply fixes..."
└── [Rest of session]
```

---

## 4. Return Loop Mechanism

### 4.1 Return Tracking State

```typescript
interface ReturnToContext {
  // Primary Key
  session_id: string
  return_id: string // unique identifier for this return context

  // Origin Info
  originating_agent_id: string
  subagent_id: string
  pass_over_id: string // link back to the PassOverRequest

  // Control Flags
  auto_return_enabled: boolean // if false, wait for explicit confirmation
  auto_apply_enabled: boolean // if true, apply changes automatically
  return_deadline?: number // unix timestamp when return must happen

  // Loop Prevention
  chain_depth: number // current depth in delegation chain
  max_chain_depth: number // usually 3-5, prevents infinite loops
  ancestors: string[] // chain of agents: ["alice", "scout", "audit"]

  // State Management
  status: "waiting_for_return" | "returned" | "timed_out" | "cancelled"
  created_at: number
  returned_at?: number

  // Result Staging
  pending_work_output?: WorkOutput
  processing_errors?: string[]
}
```

### 4.2 Automatic Return Conditions

Return happens **automatically** when:

1. **Success Completion**: Subagent marks `status: "completed"` and found no blockers
2. **Review Passes**: If auto-review policy enabled and no critical issues found
3. **Timeout**: Subagent didn't return within `timeout_ms`
4. **User Approval**: Originating agent explicitly approves in UI
5. **Policy Override**: User configured `auto_return: true` for agent pair

### 4.3 Preventing Infinite Loops

```typescript
// Before accepting a pass over request
function validatePassOverChain(request: PassOverRequest, sessionHistory: Message[]): boolean {
  const metadata = extractMetadata(sessionHistory)
  const chain = metadata.origination_chain || []

  // Check depth
  if (chain.length >= MAX_CHAIN_DEPTH) {
    throw new Error(
      `Pass over chain too deep (${chain.length}/${MAX_CHAIN_DEPTH}). ` +
        `Chain: ${chain.map((c) => c.agent_id).join(" → ")}`,
    )
  }

  // Check for cycles
  const agentCounts = new Map<string, number>()
  for (const entry of chain) {
    const count = agentCounts.get(entry.agent_id) ?? 0
    agentCounts.set(entry.agent_id, count + 1)
    if (count >= 2) {
      throw new Error(
        `Cycle detected: ${entry.agent_id} appears twice in chain. ` +
          `Chain: ${chain.map((c) => c.agent_id).join(" → ")}`,
      )
    }
  }

  // Check for suspicious patterns
  if (chain.length >= 2) {
    const last = chain[chain.length - 1]
    const secondLast = chain[chain.length - 2]
    if (last.agent_id === secondLast.agent_id) {
      throw new Error(
        `Ping-pong detected: ${last.agent_id} passed back to itself. ` + `This suggests infinite delegation loop.`,
      )
    }
  }

  return true
}
```

### 4.4 Return Flow in Session

```typescript
async function handlePassOverReturn(sessionID: string, workOutput: WorkOutput): Promise<void> {
  // 1. Validate return (must match originating agent)
  const context = await getReturnContext(sessionID)
  if (!context) {
    throw new Error(`No return context found for session ${sessionID}`)
  }
  if (context.status !== "waiting_for_return") {
    throw new Error(`Return context not in waiting state: ${context.status}`)
  }

  // 2. Validate origination
  if (workOutput.return_to !== context.originating_agent_id) {
    throw new Error(`Return agent mismatch: expected ${context.originating_agent_id}, ` + `got ${workOutput.return_to}`)
  }

  // 3. Validate chain
  const chainDepth = context.chain_depth
  if (chainDepth > context.max_chain_depth) {
    throw new Error(`Chain depth exceeded: ${chainDepth} > ${context.max_chain_depth}`)
  }

  // 4. Stage the work output
  await updateReturnContext(sessionID, {
    status: "returned",
    returned_at: Date.now(),
    pending_work_output: workOutput,
  })

  // 5. Record in session history
  await recordPassOverReturn(sessionID, {
    pass_over_id: workOutput.work_id,
    artifacts: workOutput.artifacts,
    metadata: workOutput.metadata,
    timestamp: Date.now(),
  })

  // 6. Notify originating agent (asyncronously)
  await notifyAgentOfReturn(sessionID, context.originating_agent_id, workOutput)
}
```

---

## 5. User Preferences & Configuration

### 5.1 Configuration Schema

Stored in app config (typically `.opencode/config.json` or environment):

```typescript
interface PassOverPreferences {
  // Global defaults
  defaults: {
    auto_return: boolean // default: false
    auto_apply: boolean // default: false (requires verification)
    timeout_ms: number // default: 30000
    max_chain_depth: number // default: 3
    require_confirmation: boolean // default: true
  }

  // Per-agent-pair settings
  pairs: Record<string, AgentPairPreference>
  // Key format: "alice->audit", "scout->inspector", etc.

  // Per-subagent settings (applies to all incoming passes)
  subagents: Record<string, SubagentPreference>

  // Audit trail settings
  audit: {
    log_all_passes: boolean // default: true
    log_directory?: string
    retention_days: number // default: 30
  }
}

interface AgentPairPreference {
  // Identity
  from: string // originating agent
  to: string // subagent

  // Behavior
  enabled: boolean // if false, this pair cannot pass over
  auto_return: boolean // auto-return when subagent done
  auto_apply: boolean // auto-apply if no critical findings
  require_user_approval: boolean // always ask user even if auto_apply true

  // Context
  pass_context: boolean // include full message history (default: true)
  pass_files: boolean // include file contents (default: true)
  max_context_size_bytes: number // limit on total context (default: 5MB)

  // Limits
  timeout_ms?: number // override global timeout
  max_chain_depth?: number // override global limit

  // Notifications
  notify_on_return: "always" | "only_issues" | "never"

  // History
  created_at: number
  updated_at: number
  updated_by?: string
}

interface SubagentPreference {
  // Identity
  subagent_id: string

  // Constraints
  can_receive_passes: boolean // default: true
  can_modify_files: boolean
  can_run_tools: boolean

  // Resources
  max_compute_time_ms: number
  max_memory_mb: number

  // Validation
  validate_output: boolean
  output_schema?: Record<string, any>
}
```

### 5.2 Global Configuration File

`.opencode/pass-over.json`:

```json
{
  "defaults": {
    "auto_return": false,
    "auto_apply": false,
    "timeout_ms": 30000,
    "max_chain_depth": 3,
    "require_confirmation": true
  },

  "pairs": {
    "alice->audit": {
      "enabled": true,
      "auto_return": true,
      "auto_apply": false,
      "require_user_approval": true,
      "pass_context": true,
      "pass_files": true,
      "timeout_ms": 60000,
      "notify_on_return": "always",
      "created_at": 1700000000,
      "updated_at": 1700000000
    },
    "alice->inspector": {
      "enabled": true,
      "auto_return": false,
      "auto_apply": false,
      "require_user_approval": true,
      "notify_on_return": "only_issues"
    },
    "scout->audit": {
      "enabled": false,
      "reason": "conflicting specializations"
    }
  },

  "subagents": {
    "audit": {
      "can_receive_passes": true,
      "can_modify_files": false,
      "can_run_tools": true,
      "max_compute_time_ms": 60000
    },
    "inspector": {
      "can_receive_passes": true,
      "can_modify_files": false,
      "can_run_tools": true
    }
  },

  "audit": {
    "log_all_passes": true,
    "log_directory": ".opencode/pass-over-logs",
    "retention_days": 30
  }
}
```

### 5.3 Inline Override

Originating agent can override preferences inline:

```typescript
// In Alice's code
const result = await passOver({
  subagent: "audit",
  work_context: {...},

  // Override config
  override: {
    timeout_ms: 90000, // this pass is complex
    auto_return: true, // trust audit implicitly
    auto_apply: false, // but always review results
    notify_on_return: "always",
  }
})
```

### 5.4 Preference Resolution Order

When determining effective preference:

```
1. Inline override (if provided) ← highest priority
2. Agent pair specific setting (alice->audit)
3. Subagent setting (audit.*)
4. Global default
5. System default ← lowest priority
```

---

## 6. Context Preservation

### 6.1 What's Preserved

| Context         | Preserved     | Notes                                      |
| --------------- | ------------- | ------------------------------------------ |
| Session ID      | ✓             | Subagent operates within same session      |
| Directory       | ✓             | Same working directory                     |
| Message History | ✓ (selective) | Recent context passed, old summarized      |
| File State      | ✓ (selective) | Only files relevant to work                |
| Todos           | ✓             | Current todo state captured                |
| Model/Provider  | ✓             | Subagent uses same model selection         |
| Permissions     | ✓             | Subagent inherits originator's permissions |
| Tool Access     | ~             | Configurable per pair                      |
| User Identity   | ✓             | Audit trail knows who ran what             |

### 6.2 Selective Message History

To avoid token explosion, include only recent context:

```typescript
function selectContextMessages(
  allMessages: Message[],
  limit: {
    max_messages?: number // default: 20
    max_tokens?: number // default: 50000
    lookback_minutes?: number // default: 60
  },
): Message[] {
  const now = Date.now()
  const cutoff = now - (limit.lookback_minutes ?? 60) * 60000

  let selected = allMessages.filter((m) => m.timestamp >= cutoff)

  // If still too many, take most recent
  if (limit.max_messages && selected.length > limit.max_messages) {
    selected = selected.slice(-limit.max_messages)
  }

  // Estimate tokens and trim if needed
  if (limit.max_tokens) {
    let tokenCount = 0
    const trimmed = []
    for (const msg of selected.reverse()) {
      const tokens = estimateTokens(msg)
      if (tokenCount + tokens > limit.max_tokens) break
      trimmed.unshift(msg)
      tokenCount += tokens
    }
    selected = trimmed
  }

  return selected
}
```

---

## 7. Metadata & Audit Trail

### 7.1 Pass Over Audit Log Entry

```typescript
interface PassOverAuditEntry {
  // Identity
  pass_over_id: string
  session_id: string
  timestamp: number

  // Participants
  originating_agent: string
  subagent: string
  user_id?: string

  // Request Details
  reason: string
  work_context_size_bytes: number
  expected_output_type: string

  // Execution
  started_at: number
  completed_at: number
  duration_ms: number

  // Results
  status: "completed" | "failed" | "aborted"
  artifacts_count: number
  files_modified_count: number
  issues_found_count: number

  // Return
  returned: boolean
  returned_at?: number
  applied: boolean
  applied_by?: string

  // Policy
  policy_applied: string
  policy_overrides: Record<string, any>

  // Summary
  summary: string
}
```

### 7.2 Audit Log Storage

```bash
.opencode/pass-over-logs/
├── 2024-02/
│   ├── session-abc123-passes.jsonl
│   └── session-def456-passes.jsonl
└── audit-summary.json
```

Each line is a `PassOverAuditEntry` (newline-delimited JSON).

---

## 8. Summary Generation

### 8.1 Optional Summary Generation

Subagent can generate a summary of findings:

```typescript
interface SummaryRequest {
  artifacts: WorkArtifact[]
  style: "bullet_points" | "narrative" | "decision_tree"
  max_length?: number // tokens
  focus?: "critical" | "all" | "high_level"
}

async function generateSummary(req: SummaryRequest): Promise<string> {
  // Use LLM to generate concise, readable summary
  const prompt = `
    Summarize these audit findings in ${req.style} format:
    ${JSON.stringify(req.artifacts, null, 2)}
    
    Focus: ${req.focus}
    Max length: ${req.max_length ?? 500} tokens
  `

  const response = await generateText({
    prompt,
    model: "gpt-4",
    maxTokens: req.max_length || 500,
  })

  return response
}
```

### 8.2 Summary in WorkOutput

```typescript
interface WorkOutput {
  // ... other fields
  summary: {
    // Machine-generated concise summary
    generated_summary?: string

    // Also include structured data
    decision?: "approved" | "rejected" | "needs_modification"
    findings: string[]
    recommendations?: string[]

    statistics: {
      files_modified: number
      issues_found: number
      time_elapsed_ms: number
    }
  }
}
```

---

## 9. Error Handling & Recovery

### 9.1 Pass Over Failure Modes

```typescript
enum PassOverErrorCode {
  // Request validation
  INVALID_SUBAGENT = "E001",
  CHAIN_DEPTH_EXCEEDED = "E002",
  CYCLE_DETECTED = "E003",
  DISABLED_PAIR = "E004",

  // Execution
  SUBAGENT_TIMEOUT = "E010",
  SUBAGENT_CRASHED = "E011",
  CONTEXT_OVERFLOW = "E012",
  PERMISSION_DENIED = "E013",

  // Return
  RETURN_CONTEXT_LOST = "E020",
  INVALID_WORK_OUTPUT = "E021",
  RETURN_TIMEOUT = "E022",

  // Configuration
  CONFIG_INVALID = "E030",
  PREFERENCE_CONFLICT = "E031",
}

class PassOverError extends Error {
  code: PassOverErrorCode
  context?: Record<string, any>
  recoverable: boolean
  suggestedAction?: string

  constructor(code: PassOverErrorCode, message: string, recoverable = false, suggestedAction?: string) {
    super(message)
    this.code = code
    this.recoverable = recoverable
    this.suggestedAction = suggestedAction
  }
}
```

### 9.2 Retry & Recovery

```typescript
async function passOverWithRetry(
  request: PassOverRequest,
  options: {
    max_retries?: number
    retry_delay_ms?: number
    backoff_multiplier?: number
  } = {},
): Promise<WorkOutput> {
  const maxRetries = options.max_retries ?? 3
  const delay = options.retry_delay_ms ?? 1000
  const backoff = options.backoff_multiplier ?? 2

  let lastError: PassOverError | undefined

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await executePassOver(request)
    } catch (e) {
      lastError = e as PassOverError

      if (!lastError.recoverable || attempt === maxRetries) {
        throw lastError
      }

      const waitTime = delay * Math.pow(backoff, attempt)
      await new Promise((resolve) => setTimeout(resolve, waitTime))
    }
  }

  throw lastError
}
```

---

## 10. Implementation Roadmap

### Phase 1: Core Infrastructure (Weeks 1-2)

- [ ] Define PassOverRequest/WorkOutput types
- [ ] Implement return tracking state machine
- [ ] Add loop prevention logic
- [ ] Build audit logging framework

### Phase 2: Configuration & Preferences (Weeks 2-3)

- [ ] Parse `.opencode/pass-over.json`
- [ ] Implement preference resolution order
- [ ] Build inline override mechanism
- [ ] Add validation & conflict detection

### Phase 3: Agent Integration (Weeks 3-5)

- [ ] Implement `passOver()` API for agents
- [ ] Add context preservation in WorkContext
- [ ] Build message extraction for artifacts
- [ ] Implement return notification mechanism

### Phase 4: UI & Observability (Weeks 5-6)

- [ ] Create pass over visualization
- [ ] Build audit log viewer
- [ ] Add preference management UI
- [ ] Implement progress indicators

### Phase 5: Testing & Polish (Weeks 6-7)

- [ ] Unit tests for all core functions
- [ ] Integration tests (Alice→Audit→Alice)
- [ ] Load tests for chain prevention
- [ ] User acceptance testing

---

## 11. API Examples

### 11.1 Initiating a Pass Over (Alice)

```typescript
// alice.ts
async function reviewCode(): Promise<void> {
  const workContext = {
    session_id: currentSession.id,
    directory: currentSession.directory,
    files: await gatherRelevantFiles(),
    messages: await selectContextMessages(),
    objective: "Review changes for correctness and style",
  }

  const result = await passOver({
    subagent: "audit",
    work_context: workContext,
    reason: "code_review",
    return_required: true,
    override: {
      timeout_ms: 60000,
      auto_return: true,
    },
  })

  // Handle results
  for (const artifact of result.artifacts) {
    if (artifact.type === "finding") {
      console.log(`Finding: ${artifact.message}`)
    }
  }

  // Apply changes if approved
  if (result.summary.decision === "approved") {
    await applyArtifacts(result.artifacts)
  }
}
```

### 11.2 Handling Return (Audit)

```typescript
// audit.ts
async function performReview(context: WorkContext): Promise<void> {
  const artifacts: WorkArtifact[] = []

  // Run analysis
  for (const file of context.files) {
    const findings = await analyzeFile(file)
    artifacts.push(...findings)
  }

  // Return to originator
  await returnFromPassOver({
    status: "completed",
    artifacts,
    summary: {
      decision: findings.critical.length === 0 ? "approved" : "rejected",
      findings: findings.all.map((f) => f.message),
      files_modified: 0,
      files_reviewed: context.files.length,
      issues_found: findings.all.length,
      time_elapsed_ms: Date.now() - startTime,
    },
  })
}
```

---

## 12. Future Enhancements

- **Conditional Passes**: Pass over only if certain conditions met
- **Batched Passes**: Multiple passes in single request
- **Streaming Results**: Real-time result delivery instead of waiting
- **Pass Over Pipelines**: Pre-configured chains (Alice→Scout→Audit)
- **Result Caching**: Cache decisions for identical contexts
- **Agent Learning**: Remember successful pass over patterns
- **Cross-Session Passes**: Pass between different user sessions
- **Permission Boundaries**: Fine-grained resource access control

---

## 13. Glossary

- **Pass Over**: Delegation of work from one agent to another with context preservation
- **Originating Agent**: The agent that initiates the pass over
- **Subagent**: The agent that receives and executes the pass over work
- **Work Output**: Artifacts, decisions, and metadata returned by subagent
- **WorkContext**: Complete snapshot of work state passed to subagent
- **Return Loop**: Mechanism by which control and results flow back to originator
- **Chain Depth**: Count of how many agents in current delegation chain
- **Policy**: Per-pair configuration controlling pass over behavior
- **Artifacts**: Tangible results (files, decisions, findings) from subagent work

---

## Appendix A: Example Pass Over Cycle

```
User Input: "Review and fix the build errors"

[Alice receives prompt]
1. Alice analyzes: "Multiple build errors detected"
2. Alice constructs PassOverRequest
   - originating_agent_id: "alice"
   - subagent_id: "audit"
   - reason: "validate_approach_and_review"
   - return_required: true

[Audit receives context]
3. Audit receives WorkContext with:
   - Error logs
   - Build configuration files
   - Source files related to errors
   - Recent conversation history

4. Audit analyzes:
   - Runs build commands
   - Identifies root causes
   - Prepares corrections
   - Records all findings

5. Audit constructs WorkOutput:
   - artifacts: [FileModificationArtifact × 3, FindingArtifact × 5]
   - status: "completed"
   - decision: "needs_modification"
   - summary with recommendations

[Alice receives results]
6. Metadata attached:
   - pass_over_id: "pass-xxx"
   - created_at: 1700000000
   - returned_at: 1700000060
   - chain_depth: 1
   - applied: false

7. Alice reviews WorkOutput:
   - Approves 2 file modifications
   - Rejects 1 modification
   - Records decision

8. Alice applies approved changes:
   - Integrates file modifications
   - Updates session state
   - Runs post-fix verification
   - Continues session

9. Audit trail records:
   - PassOverAuditEntry with full lifecycle
   - Applied changes with timestamps
   - User approvals logged
```
